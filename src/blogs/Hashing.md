# Hashing

## Hash Function Principles
Ideally, we want a hash function that maps keys to slots in a way that makes each slot in the hash table have equal probablility of being filled for the actual set keys being used.

### Design hash functions challenges
When designing hash functions, we are generally faced with one of two situations:

1. We know nothing about the distribution of the incoming keys. In this case, we wish to select a hash function that evenly distributes the key range across the hash table, while avoiding obvious opportunities for clustering such as hash functions that are sensitive to the high- or low-order bits of the key value.

2. We know something about the distribution of the incoming keys. In this case, we should use a distribution-dependent hash function that avoids assigning clusters of related key values to the same hash table slot. For example, if hashing English words, we should not hash on the value of the first character because this is likely to be unevenly distributed.

## Binning
> For keys in the range 0-999, and have a hash table of size 10.
>
> In this case, a possible hash function might simply divide the key value by 100.
>
> Thus, keys of 0-99 -> slot 0; keys 100-199 -> slot 1; etc.

## Mid-Square Method
| ![Mid Square Method Hashing Example](/images/MidSquareHash.png) |
| :---: |
> Result = $r$ middle digits(The key squared)

## Simple Hash Function for Strings
| ![Simple Hash Function for Strings Example](/images/SampleStringHash.png) |
| :---: |
> Result = Sum of ASCII values of characters

## String Folding
| ![String Folding Example](/images/StringFolding.png) |
| :---: |
> Result = Mod(Sum(integers of 4 bytes chunk)) = (1633771871 ("aaaa") + 1650614882 ("bbbb")) % 100 = 3284386755 % 100 = 55
>
> Mod values are based on hash table size. In this case, size = 100

## Open Hash System (Seperate Chaining)
> A hash system where multiple records might be associated with the same slot of a hash table
>
> Collisions are stored outside of the table

Typically this is done usign a linked list to store the records

## Closed Hash System (Open Addressing)
> A hash system where all records are stored in slots of the hash table
>
>Collisions are stored at another slot in the hash table

## Collision Resolution
> Find a free slot in the hash table if the home position for the record is occupied

The function used to find the next slot is called `probe function`

## Linear probing
> A collision resolution that works by moving to the next slot sequentially in the hash table

![Linear Probe Problem](/images/LinearProbProblem.png)
> The probability of distributing keys to slots are not evenly divided

## Linear probing by steps
> A linear probing but skip slots by some constant c other than 1

## Pseudo Random probing
> Given a permutation array, elements in the array are steps away from the base slot. 

This eliminates clustering problem

Problem: Secondary clustering -> double hashing 

## Quadratic Probing
Also eliminates clustering problem
> Number of steps from the base slot are in quadratic from of $c_1i^2 + c_2i + c_3$
>
> Simplest variation is $p(K,i)=i^2$ (i.e., $c_1=1$, $c_2=0$, and $c_3=0$) -> Therefore, [1, 4, 9, 16, 25]

Problem: the probe sequence will not visit all slots in the hash table. For example, $p(K,i) = i^2$ only end in 0, 1, 4, 5, 6, 9
Another problem: Secondary clustering -> double hashing 

### Primary clustering (need reviews)
> In hashing, the tendency in certain collision resolution methods to create clustering in sections of the hash table. The classic example is linear probing. This tends to happen when a group of keys follow the same probe sequence during collision resolution.

### Secondary clustering (need reviews)
> In hashing, the tendency in certain collision resolution methods to create clustering in sections of the hash table. In primary clustering, this is caused by a cluster of keys that donâ€™t necessarily hash to the same slot but which following significant portions of the same probe sequence during collision resolution. Secondary clustering results from the keys hashing to the same slot of the table (and so a collision resolution method that is not affected by the key value must use the same probe sequence for all such keys). This problem can be resolved by double hashing since its probe sequence is determined in part by a second hash function.

### Double Hashing  
> A collision resolution method. A second hash function is used to generate a value c on the key. That value is then used by this key as the step size in linear probing by steps. Since different keys use different step sizes (as generated by the second hash function), this process avoids the clustering caused by standard linear probing by steps.

### Tombstone
> In hashing, a tombstone is used to mark a slot in the hash table where a record has been deleted. Its purpose is to allow the collision resolution process to probe through that slot (so that records further down the probe sequence are not unreachable after deleting the record), while also allowing the slot to be reused by a future insert operation.